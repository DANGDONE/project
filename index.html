<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="DANGDONE : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>DANGDONE</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/DANGDONE/project">View on GitHub</a>

          <h1 id="project_title">DANGDONE</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/DANGDONE/project/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/DANGDONE/project/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="Introduction" class="anchor" href="#Introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Dangling pointers have become an important class of software bugs that could result in use-after-free and double-free vulnerabilities. 
The effects of their exploitation can lead to information leakage, privilege elevation or even control-flow hijacking.
So far, only few approaches are proposed to protect against dangling pointers and most of them incur high overhead.
In this paper we present a lightweight approach, named DANGDONE, to eliminate dangling pointers during the compilation time.
Because the root cause of a dangling pointer is that the pointer and its aliases are not nullified after the objects they point-to are
deallocated,
DANGDONE achieves the protection via three steps:
(1) inserting new pointers point to vulnerable pointers, (2) using new pointers to keep track of aliases vulnerable pointers, and (3) 
automatically nullifying pointers (a.k.a. intermediate pointers) whose memory contents are explicitly deallocated.
DANGDONE is implemented as the compile-time instrumentation and transformation which require no intervention from programmers. 
Then the Nullification of the explicit freed pointer will eliminate all dangling pointers that are aliases of the freed pointer.
We also design a conservative static analysis method to reduce the unnecessary transformation. 
Experimental results show that DANGDONE can protect the target software (the SPEC CPU benchmarks and programs with known CVE) with
negligible performance overhead (<1% with the proposed static analysis).</p>

<h3>
<a id="Overview" class="anchor" href="#Overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>

<p>The basic idea of DANGDONE is as follows: first inserts an new pointer pointing to the pointer which is marked as vulnerable
by static analysis, and then the new pointer is used to keep the pointer propagation consistent with the vulnerable pointer. 
Note that aliases of the vulnerable pointer are also vulnerable, so they are all have the corresponding new pointers, which make 
it possible to keep the pointer propagation consistent with the vulnerable pointer. The instrumentation will make all aliases of 
the new pointer point to one vulnerable pointer. Then we replace uses of the vulnerable pointer with the new pointer if the vulnerable
pointer is dereferenced. When the vulnerable pointer is deallocated, DANGDONE nullifies the freed pointers automatically.</p>
<p style="text-align:center;"><img src="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/overview.png" alt="Overview of DANGDONE" width="600" ></p>
<h3>
<a id="Prototype" class="anchor" href="#Prototype" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prototype</h3>

<p>The approach proposed in this work is applicable for source code, intermediate representation, and even binary if
the type information is available. Currently, we implemented DANGDONE at intermediate representation (IR) level based on
the LLVM Compiler project for the reason of efficiency and cross-language support. Furthermore, the code transformation at
the source code level may not be helpful for the readability and maintainability.The static analysis phase in DANGDONE is built
as a Clang Tool and the transformation phase is implemented as an extra LLVM pass. A LLVM pass performs the transformations
and optimizations that make up the compiler. The source code for it can be found 
<a href="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/DANGDONE.zip">here.</a> The way how to use it can be found 
<a href="https://github.com/DANGDONE/project/tree/master/dangdone">here</a> </p>
<h3>
<a id="Experiment" class="anchor" href="#Experiment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Experiment</h3>
<p>Overall experimental results can be found <a href="https://dangdone.github.io/project/experiment.html">here!</a> Some detailed experiment result can be found <a href="https://github.com/DANGDONE/project/tree/master/test">here</a></p>
<!--
<p style="text-align:center;"><img src="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/experiment.png" alt="" width="600" ></p>
-->
<h3>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Project maintained by <a href="https://github.com/DANGDONE">DANGDONE</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
