<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="DANGDONE : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>DANGDONE</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/DANGDONE/project">View on GitHub</a>

          <h1 id="project_title">DANGDONE</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/DANGDONE/project/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/DANGDONE/project/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="Introduction" class="anchor" href="#Introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Dangling pointers have become an important class of software bugs that can lead to use-after-free and double-free vul-nerabilities. So far, only a few approaches have been proposed to protect against dangling pointers, while most of them suffer from high overhead. In this paper, we propose a lightweight approach, named DANGDONE, to eliminate dangling pointers at the compile time. Based on the root cause of a dangling pointer, i.e., a pointer and its aliases are not nulliﬁed but the object they point to is deal-located, DANGDONE realizes the protection by four steps. First, it creates a new pointer that points to a vulnerable pointer. Second, it creates new pointers to track aliases of the vulnerable pointer. Third, it replaces the use of the vulnerable pointer and its aliases with the new pointers, and thus all the new pointers point to the vulnerable pointer (a.k.a. intermediate pointer). Last, it nulliﬁes the vulnerable pointer whose memory area is deallocated. These four steps are designed as compile-time program transformation, which requires no intervention from users. Experimental results have indicated that DANGDONE can protect target programs (the SPEC CPU benchmarks and programs with known CVEs) with negligible runtime overhead (i.e., around 1% on average).</p>

<h3>
<a id="Overview" class="anchor" href="#Overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>

<p>The basic idea of DANGDONE is as follows: 1) create a new pointer that points to the vulnerable pointer; 2) create a new pointer for each alias of the vulnerable pointer and use these new pointers to track pointer propagations such that the new pointers maintain the same point-to relations as the vulnerable pointer and its aliases; 3) replace the use of the vulnerable pointer and its aliases with the new pointers; and 4) nullify the vulnerable pointer when the vulnerable pointer is deallocated. By this means, the protection of the vulnerable pointers is reduced to the protection of the new pointers, which can be simply realized by nullifying those vulnerable (or intermediate) pointers as the new pointers and their aliases all point to those vulnerable pointers. </p>
<p style="text-align:center;"><img src="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/overview.png" alt="Overview of DANGDONE" width="600" ></p>
<h3>
<a id="Prototype" class="anchor" href="#Prototype" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prototype</h3>

<p>The proposed approach is applicable for source code, intermediate representation, and even binary if the type information is available. Currently, we implemented DANGDONE at the intermediate representation (IR) level based on LLVM for the sake of efﬁciency and cross-language support. The transformation in DANGDONE is implemented as a LLVM pass. A LLVM pass performs the transformations and optimizations that make up the compiler. Therefore, the workﬂow of DANGDONE is that 1) Clang compiles a target project into LLVM IR; 2) DANGDONE applies a LLVM pass to transform the LLVM IR; and 3) Clang compiles the transformed LLVM IR to binary. The source code for it can be found 
<a href="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/DANGDONE.zip">here.</a> Instructions for compiling it can be found 
<a href="https://github.com/DANGDONE/project/tree/master/dangdone">here.</a> </p>
<h3>
<a id="Experiment" class="anchor" href="#Experiment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Experiment</h3>
<p>Overall experimental results can be found <a href="https://dangdone.github.io/project/experiment.html">here!</a> Some detailed experiment result can be found <a href="https://github.com/DANGDONE/project/tree/master/test">here</a></p>
<!--
<p style="text-align:center;"><img src="https://raw.githubusercontent.com/dangdone/project/gh-pages/images/experiment.png" alt="" width="600" ></p>
-->
<h3>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Project maintained by <a href="https://github.com/DANGDONE">DANGDONE</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
